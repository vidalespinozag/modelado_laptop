# -*- coding: utf-8 -*-
"""modelado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dK2FGOOIRgBCuk2mrIikJWk6walr9jul
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
#modelado
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error

df = pd.read_csv('laptop_price.csv', encoding='ISO-8859-1')
df.head(10)

sns.histplot(df['Price_euros'])
plt.title("Distribucion de Precios")
plt.xlabel("Precio")
plt.ylabel("Fre")
plt.show()

plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='Company', y='Price_euros')
plt.title('Relación entre Precio y Compañia')
plt.xlabel('Compañia')
plt.ylabel('Precio (Euros)')
plt.xticks(rotation=45)
plt.show()

razer_laptops = df[df['Company'] == 'MSI']
razer_laptops.head(25)

plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='TypeName', y='Price_euros')
plt.title('Relación entre Precio y Tipo')
plt.xlabel('Tipo de laptop')
plt.ylabel('Precio (Euros)')
plt.xticks(rotation=45)
plt.show()

razer_laptops = df[df['TypeName'] == 'Gaming'].sort_values(by='Price_euros', ascending=False)['Price_euros']
razer_laptops.head(25)

plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='Inches', y='Price_euros')
plt.title('Relación entre Precio y Tamaño de pantalla')
plt.xlabel('Tamaño de pantalla')
plt.ylabel('Precio (Euros)')
plt.xticks(rotation=45)
plt.show()

razer_laptops = df[df['Inches'] == 17.3].sort_values(by='Price_euros', ascending=False)['Price_euros']
razer_laptops.head(25)

#CONVERTIR A NUMERO LA COLUMNA TYPE
#df['Ram'] = df['Ram'].str.extract('(\d+)').astype(int)
#df['Memory'] = df['Memory'].str.extract('(\d+)').astype(int)
df['Weight'] = df['Weight'].str.extract('(\d+)').astype(int)

df['Ram'].head(100)

#PRUEBA
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='OpSys', y='Price_euros')
plt.title('Relación entre Precio y Sistema Operativo')
plt.xlabel('Sistema Operativo')
plt.ylabel('Precio (Euros)')
plt.xticks(rotation=45)
plt.show()

df_ohe = pd.get_dummies(df, columns=['Company'], drop_first=True)

# Mostrar las primeras filas del DataFrame resultante
df_ohe.head()

# Seleccionar las features relevantes
#features = df[['OpSys', 'Ram', 'Memory', 'Cpu', 'Gpu']]
features = df[['Company']]
target = df['Price_euros']

features = pd.get_dummies(features, columns=['Company'], drop_first=True)

features.head()

features = features.dropna()
target = target.loc[features.index]
print(target)

# Seleccionar solo las columnas numéricas del DataFrame
numeric_df = features.select_dtypes(include='boolean')


# Eliminar columnas que tengan solo valores NaN o que no sean útiles
numeric_df_cleaned = numeric_df.dropna(axis=1, how='all')

# Calcular la matriz de correlación
correlation_matrix = numeric_df_cleaned.corr()

# Verificar que la matriz de correlación no esté vacía
if correlation_matrix.empty:
    print("No hay suficientes datos numéricos para calcular una correlación.")
else:
    # Mostrar la matriz de correlación
    plt.figure(figsize=(10, 8))
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
    plt.title('Matriz de Correlación de Features Numéricas')
    plt.show()

numerical_features = df[['Price_euros', 'Ram', 'Memory','Inches','Weight']]  # Agrega más columnas numéricas si es necesario
correlation_matrix = numerical_features.corr()
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Matriz de Correlación')
plt.show()

df_encoded = pd.get_dummies(df, columns=['Company'], drop_first=True)

# Seleccionar las características (features) y la variable objetivo (target)
features = df_encoded[['Ram', 'Memory','Inches']]  # Puedes agregar más columnas numéricas
target = df_encoded['Price_euros']
X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.2, random_state=42)
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)
y_pred = rf_model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
rmse = mse ** 0.5
print(f'Root Mean Squared Error (RMSE): {rmse}')